# -*- coding: utf-8 -*-
"""
/***************************************************************************
 GLAMethod
                              -------------------
        begin                : 2014-08-30
        copyright            : (C) 2014 by Christian Boehnke
        email                : christian@home-boehnke.de
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

"""
/***************************************************************************
 *	  GLA Method
 *	  calculate the ability of a cover above an aquifer to protect the 
 *	  groundwater
 ***************************************************************************/
"""
from PyQt4.QtCore import *
from PyQt4.QtGui import *
from qgis.core import *
from qgis.gui import *
from ui_Files.ui_GLA_dialog import Ui_GLA_dialog
from GLA_Loose import LithLoose
from GLA_Solid import LithSolid
import resources_rc

#import help_dialog

import os, sys, time
from osgeo import gdal, ogr, osr
from osgeo.gdalconst import *

import csv
import zipfile, itertools
import numpy as np
from matplotlib.path import Path
import fnmatch
import webbrowser

class GLAMethod(QDialog, Ui_GLA_dialog):

	def __init__(self, iface):
		# setup UI and connect the buttons
		QDialog.__init__(self)
		self.iface = iface
		self.setupUi(self)
		
		#self.updateUi(self)
		
		
		
		# connect the buttons
		# by clicking the buttons do a proper action defined below 
		self.connect(self.btnOutput, SIGNAL("clicked()"), self.outFile)
		self.connect(self.btnDefDir, SIGNAL("clicked()"), self.LookUpDir)
		self.connect(self.btnLITH_l, SIGNAL("clicked()"), self.openDialog_l)
		self.connect(self.btnLITH_s, SIGNAL("clicked()"), self.openDialog_s)
		self.connect(self.btnRun, SIGNAL("clicked()"), self.accept)
#		self.connect(self.btnRun, SIGNAL("accepted()"), self.accept)
		self.connect(self.btnClose, SIGNAL("clicked()"), self.close)
#		QObject.connect(self.btnClose, SIGNAL("rejected()"), self, SLOT("reject()"))
		self.connect(self.chBPerched, SIGNAL("stateChanged(int)"), self.changePerched)
		self.connect(self.chBArtesian, SIGNAL("stateChanged(int)"), self.changeArtesian)
		
		# choose wether you want to input groundwater recharge or climatic data
		self.connect(self.rbtnGWR, SIGNAL("clicked()"), self.radiobuttonGWR)
		self.connect(self.rbtnCWB, SIGNAL("clicked()"), self.radiobuttonCWB)
		
		# set climatic data disabled, by default, enable by toggling radio buttons above
		self.cmbCWBTab.setEnabled(False)

		mapCanvas = self.iface.mapCanvas()
		# init dictionaries of items:
		self.rastItems = {}
		
		# perched and artesian groundwater is optional
		# disable combo boxes for perched and artesian groundwater 
		# enable only when data is available
		self.cmbPerched.setEnabled(False)
		self.cmbArtesian.setEnabled(False)
		
		# enable perched and artesian groundwater
		
		# map over all layers in Q layer list
		# layers can be activated or deactivated		
		for layer in self.iface.legendInterface().layers():
			if layer.type() == QgsMapLayer.RasterLayer:
				
				# read layer into combobox, when selected
				self.cmbFC.addItem(layer.source())
				self.cmbGWR.addItem(layer.source())
				self.cmbPerched.addItem(layer.source())
				self.cmbArtesian.addItem(layer.source())
			
			elif layer.type() == QgsMapLayer.VectorLayer:
				self.cmbFC.addItem(layer.source())
				self.cmbGWR.addItem(layer.source())
				self.cmbPerched.addItem(layer.source())
				self.cmbArtesian.addItem(layer.source())				
				
		# look up current directory
		self.currentDIR = unicode(os.path.abspath( os.path.dirname(__file__)))
		
		self.currentDIR_lookup = os.path.join(self.currentDIR, "LOOKUP")
		self.leDefDir.insert(self.currentDIR_lookup)
		self.DefDirtext = self.leDefDir.text()

		self.loadLookup()
		self.lith_l = LithLoose(self)
		self.lith_s = LithSolid(self)
		# clear messages window
		self.textEdit.clear()

	def btnClose(self):
		self.close()
	
	def accept(self):
	
		self.btnRun.setEnabled(False)
		
#		self.openInfo()
		
		
		try:
			self.readFCTab()
		
			if self.rbtnGWR.isChecked():
				self.readGWRTab()
			elif self.rbtnCWB.isChecked():
				self.readCWBTab()
	
			self.readLITHTab_l()
			self.readLITHTab_s()
			
		except:
			self.textEdit.append("Aborted...")
			return
			
		

		# execute ProcessRaster function
		# input are input layers from comboboxes
		# return array data for further calculations
		try:
			self.ProcessRaster()
		
		except:
			QMessageBox.information(None,"Info","Could not start calculation. Check your input files.")
			self.textEdit.append("Aborted...")
			return		

		
		
		self.calcFC()
		

		# there are two inputs for percolating water (GWR & CWB)
		# check which one is selected
		if self.rbtnGWR.isChecked():
			self.calcGWR()
			
			
		elif self.rbtnCWB.isChecked():
			self.calcCWB()
			
			
		if (len(self.lith_l.asso_list_l)) and (len(self.lith_s.asso_list_s)):
			self.calcLITH_l()
			self.calcLITH_s()
		#	self.textEdit.append("Calculated on unconsolidated and consolidated lithology")

		elif (len(self.lith_l.asso_list_l)) and not (len(self.lith_s.asso_list_s)):
			self.calcLITH_l()
			self.arrayLITH_s = self.dataPercol[:] * 0
			

		elif (len(self.lith_s.asso_list_s)) and not (len(self.lith_l.asso_list_l)):
			self.calcLITH_s()
			self.arrayLITH_l = self.dataPercol[:] * 0
			

		elif not (len(self.lith_l.asso_list_l)) and not (len(self.lith_s.asso_list_s)):
			QMessageBox.information(None,"Info","No lithology found. Please select directories for loose or solid lithology, or both.")
			self.textEdit.append("Aborted...")
			return
		
		else:
			QMessageBox.information(None,"Info","No lithology found. Please select directories for loose or solid lithology, or both.")
			self.textEdit.append("Aborted...")
			return
			
			
		
		self.calcGLA()
		
		self.writeTextureGeoTiff()
		
		
		if self.chBProcRast.isChecked():
			self.writeProcessGeoTiff()

	def loadLookup(self):
		# apply lookup tables from default directory to combo boxes
		
		self.cmbFCTab.clear()
		self.cmbGWRTab.clear()
		self.cmbCWBTab.clear()
		self.cmbLITHTab_l.clear()
		self.cmbLITHTab_type.clear()
		self.cmbLITHTab_struc.clear()
		
		listDat = [s for s in os.listdir(self.DefDirtext) if fnmatch.fnmatch(s,'*.csv')]
		self.cmbFCTab.addItems(["FC.csv"] if "FC.csv" in listDat else listDat)
		self.cmbGWRTab.addItems(["GWR.csv"] if "GWR.csv" in listDat else listDat)
		self.cmbCWBTab.addItems(["CWB.csv"] if "CWB.csv" in listDat else listDat)
		self.cmbLITHTab_l.addItems(["looserock.csv"] if "looserock.csv" in listDat else listDat)
		self.cmbLITHTab_type.addItems(["solidrock_type.csv"] if "solidrock_type.csv" in listDat else listDat)
		self.cmbLITHTab_struc.addItems(["solidrock_structure.csv"] if "solidrock_structure.csv" in listDat else listDat)

		self.FCTab = self.cmbFCTab.currentText()
		self.FCTab = os.path.join(self.DefDirtext,str(self.FCTab))	
		
		self.GWRTab = self.cmbGWRTab.currentText()
		self.GWRTab = os.path.join(self.DefDirtext,str(self.GWRTab))	

		self.CWBTab = self.cmbCWBTab.currentText()
		self.CWBTab = os.path.join(self.DefDirtext,str(self.CWBTab))		
		
		self.LITHTab_l = self.cmbLITHTab_l.currentText()
		self.LITHTab_l = os.path.join(self.DefDirtext,str(self.LITHTab_l))
		
		self.LITHTab_type = self.cmbLITHTab_type.currentText()
		self.LITHTab_type = os.path.join(self.DefDirtext,str(self.LITHTab_type))
		
		self.LITHTab_struc = self.cmbLITHTab_struc.currentText()
		self.LITHTab_struc = os.path.join(self.DefDirtext,str(self.LITHTab_struc))		

	def help(self):
		hlp = help_dialog.Help(self.iface)
		hlp.exec_()
			
	def radiobuttonGWR(self):
		self.cmbGWRTab.setEnabled(True)
		self.cmbCWBTab.setEnabled(False)
	
	def radiobuttonCWB(self):
		self.cmbGWRTab.setEnabled(False)
		self.cmbCWBTab.setEnabled(True)
				
	def changePerched(self):
		if self.chBPerched.isChecked():
			self.cmbPerched.setEnabled(True)
		else:
			self.cmbPerched.setEnabled(False)
			
	def changeArtesian(self):
		if self.chBArtesian.isChecked():
			self.cmbArtesian.setEnabled(True)
		else:
			self.cmbArtesian.setEnabled(False)
			
	# --------------------------------------
	# define error messages
	# --------------------------------------
	
	t_lookup_path = "Could not find your Look-up tables! You may forgot to declare the filepath."
	t_lookup_table = "An error occured! Check your look-up tables. They must meet the requirements.Please refer to the help."
	t_open_raster = "Could not open raster! Check, if raster files are loaded into QGIS."
	
		
	# --------------------------------------
	# get output filename
	# --------------------------------------
		
	def outFile(self):
		# open a file dialog, when clicking the browse button in the input tab
		# choose a directory for the output file to be saved in
		# choose a filename to be saved and hand over the filepath to the variable "outName"
		# function output is filepath
		
		# display file dialog for output raster file
		self.lineOutput.clear()
		
		# execute QFileDialog, when clicking the output button and get filename to be saved
		outName = QFileDialog.getSaveFileName(self, "Raster output file",".", "GeoTiff (*.tif);;Grid (*grd)")
		
		# display filename in lineOutput
		self.lineOutput.insert(outName)
		self.outName = self.lineOutput.text()
		
		self.readFCRaster()
		
		self.spb_row.setValue(self.rows)
		self.spb_col.setValue(self.cols)
		self.spb_xmin.setValue(self.XMin)
		self.spb_ymax.setValue(self.YMax)
		self.spb_xmax.setValue(self.XMax)
		self.spb_ymin.setValue(self.YMin)
		
	# --------------------------------------
	# get loose lithology 
	# --------------------------------------		

	def openDialog_l(self):
		self.lith_l.exec_()

	# --------------------------------------
	# get solid lithology 
	# --------------------------------------		
	
	def openDialog_s(self):
		self.lith_s.exec_()			

	# --------------------------------------
	# get look up directory
	# --------------------------------------
		
	def LookUpDir(self):
		# open a directory dialog, when clicking the browse button in the look up tab
		# choose the directory
		
		self.leDefDir.clear()
		
		DefDir_new = QFileDialog.getExistingDirectory(self)
		if not DefDir_new:
			self.leDefDir.insert(self.currentDIR_lookup)
		
		else:
			self.leDefDir.insert(DefDir_new)
		
		self.DefDirtext = self.leDefDir.text()
		self.loadLookup()

	# --------------------------------------
	# read raster file
	# --------------------------------------
	
	def readFCRaster(self):
		#Register all of the GDAL drivers
		gdal.AllRegister()
		
		# open the image
		FC = str(self.cmbFC.currentText())

		self.imgFC = gdal.Open(FC,GA_ReadOnly)
		
		if self.imgFC is None is None:
			QMessageBox.information(None,"Exiting",self.t_open_raster)

		# get image size and number of bands
		self.rows = self.imgFC.RasterYSize
		self.cols = self.imgFC.RasterXSize

		# get georeference info from FC image
		transform = self.imgFC.GetGeoTransform()
		self.XMin = transform[0]
		self.pixelWidth = transform[1]
		self.rotation2 = transform[2]
		self.YMax = transform[3]
		self.rotation4 = transform[4]
		self.pixelHeight = transform[5]
		
		self.XMax = abs(self.cols * self.pixelWidth) + self.XMin
		self.YMin = self.YMax - (abs(self.rows * self.pixelHeight))

	def ProcessRaster(self):
		# input content of comboboxes, these are the input files
		# open input raster with GDAL methods
		# function output are rasters as arrays and georeference information
		
		#Register all of the GDAL drivers
		gdal.AllRegister()
		
		self.textEdit.append("Starting...")
		
		# open the image
		Percol = str(self.cmbGWR.currentText())

#		imgPercol = gdal.Open(Percol,GA_ReadOnly)
		
		# read raster data as array and print status message
		self.dataFC = self.imgFC.ReadAsArray()
		self.dataFC = self.dataFC.astype(float)
		
		#QMessageBox.information(None,"Raster %s loaded successfully" % FC)

		self.imgPercol = gdal.Open(Percol)
		self.dataPercol = self.imgPercol.ReadAsArray()
		self.dataPercol = self.dataPercol.astype(float)
		
#		self.dataPercol = imgPercol.ReadAsArray()
		#QMessageBox.information(None,"Raster %s loaded successfully" % Percol)
		
		# open if available (use check boxes)
		if self.chBPerched.isChecked():
			Perched = str(self.cmbPerched.currentText())
			imgPerched = gdal.Open(Perched,GA_ReadOnly)
			
			if imgPerched is None:
				QMessageBox.information(None,"Exiting",self.t_open_raster)
			dataPerched = imgPerched.ReadAsArray()
			dataPerched = dataPerched.astype(float)
			self.arrayPerched = dataPerched[:] *  500
		else:
			self.arrayPerched = self.dataFC[:] * 0			# if perched layer is not used, create an 0-array of size of FC layer
		
		if self.chBArtesian.isChecked():
			Artesian = str(self.cmbArtesian.currentText())
			imgArtesian = gdal.Open(Artesian,GA_ReadOnly)
			if imgArtesian is None:
				QMessageBox.information(None,"Exiting",self.t_open_raster)
			dataArtesian = imgArtesian.ReadAsArray()
			dataArtesian = dataArtesian.astype(float)
			self.arrayArtesian = dataArtesian[:] *  1500
		else:
			self.arrayArtesian = self.dataFC[:] * 0		# if artesian layer is not used, create an 0-array of size of FC layer
			
		self.textEdit.append("Input rasters loaded successfully")	
	
	# --------------------------------------
	# read look up table
	# --------------------------------------
	
	def readFCTab(self):
	# input is directory for look up tables
	# read FC csv-tables when combo boxes are clicked
	# convert csv to list
	# list contains minimum and maximum limits and a point value for each interval
			
		try:
			FCcsv = csv.DictReader(open(self.FCTab, "rb"), delimiter=';')
		except:
			QMessageBox.information(None,"Info",self.t_lookup_path)
			return
			
		self.FCMin = []
		self.FCMax = []
		self.FCPoints = []
	
		try:
			for line in FCcsv:
				self.FCMin.append(line["Min"])
				self.FCMax.append(line["Max"])
				self.FCPoints.append(line["Points"])

			self.FCMin = [float(i) for i in self.FCMin]
			self.FCMax = [float(i) for i in self.FCMax]
			self.FCPoints = [float(i) for i in self.FCPoints]
		except:
			QMessageBox.information(None,"Info",self.t_lookup_table)
			return

	def readGWRTab(self):
	# input is directory for look up tables
	# read GWR csv-tables when combo boxes are clicked
	# convert csv to list
	# list contains minimum and maximum limits and a point value for each interval	
		
		try:
			GWRcsv = csv.DictReader(open(self.GWRTab, "rb"), delimiter=';')
		except:
			QMessageBox.information(None,"Info",self.t_lookup_path)
			return
		
		self.GWRMin = []
		self.GWRMax = []
		self.GWRPoints = []
	
		try:
			for line in GWRcsv:
				self.GWRMin.append(line["Min"])
				self.GWRMax.append(line["Max"])
				self.GWRPoints.append(line["Points"])

			self.GWRMin = [float(i) for i in self.GWRMin]
			self.GWRMax = [float(i) for i in self.GWRMax]
			self.GWRPoints = [float(i) for i in self.GWRPoints]
		except:
			QMessageBox.information(None,"Info",self.t_lookup_table)
			return

	def readCWBTab(self):
	# input is directory for look up tables
	# read CWB csv-tables when combo boxes are clicked
	# convert csv to list
	# list contains minimum and maximum limits and a point value for each interval
		
		try:
			CWBcsv = csv.DictReader(open(self.CWBTab, "rb"), delimiter=';')
		except:
			QMessageBox.information(None,"Info",self.t_lookup_path)
			return
		
		self.CWBMin = []
		self.CWBMax = []
		self.CWBPoints = []
	
		try:
			for line in CWBcsv:
				self.CWBMin.append(line["Min"])
				self.CWBMax.append(line["Max"])
				self.CWBPoints.append(line["Points"])

			self.CWBMin = [float(i) for i in self.CWBMin]
			self.CWBMax = [float(i) for i in self.CWBMax]
			self.CWBPoints = [float(i) for i in self.CWBPoints]
		except:
			QMessageBox.information(None,"Info",self.t_lookup_table)
			return

	def readLITHTab_l(self):
	# input is directory for look up tables
	# read lithology csv-tables when combo boxes are clicked
	# convert csv to list
	# list contains lithology names and a point value for each interval	
			
		try:
			LITHcsv_l = csv.DictReader(open(self.LITHTab_l, "rb"), delimiter=';')
		except:
			QMessageBox.information(None,"Info",self.t_lookup_path)
			return
		
		self.LITHShort_l = []
		self.LITHPoints_l = []
	
		try:
			for line in LITHcsv_l:
				self.LITHShort_l.append(line["Short"])
				self.LITHPoints_l.append(line["Points"])

			self.LITHShort_l = [str(i) for i in self.LITHShort_l]
			self.LITHPoints_l = [float(i) for i in self.LITHPoints_l]
		except:
			QMessageBox.information(None,"Info",self.t_lookup_table)
			return

	def readLITHTab_s(self):
	# input is directory for look up tables
	# read lithology csv-tables when combo boxes are clicked
	# convert csv to list
	# list contains lithology names and a point value for each interval	
			
		try:
			LITHcsv_type = csv.DictReader(open(self.LITHTab_type, "rb"), delimiter=';')
			LITHcsv_struc = csv.DictReader(open(self.LITHTab_struc, "rb"), delimiter=';')
		except:
			QMessageBox.information(None,"Info",self.t_lookup_path)
			QMessageBox.information(None,"Info",self.t_lookup_path)
			return
		
		self.LITHName_type = []
		self.LITHPoints_type = []
		
		self.LITHName_struc = []
		self.LITHPoints_struc = []
	
		try:
			for line in LITHcsv_type:
				self.LITHName_type.append(line["Type"])
				self.LITHPoints_type.append(line["Points"])

			self.LITHName_type = [str(i) for i in self.LITHName_type]
			self.LITHPoints_type = [float(i) for i in self.LITHPoints_type]
			
			for line in LITHcsv_struc:
				self.LITHName_struc.append(line["Structure"])
				self.LITHPoints_struc.append(line["Points"])

			self.LITHName_struc = [str(i) for i in self.LITHName_struc]
			self.LITHPoints_struc = [float(i) for i in self.LITHPoints_struc]
		except:
			QMessageBox.information(None,"Info",self.t_lookup_table)
			return

	# --------------------------------------
	# calculate FC array
	# --------------------------------------	
	
	def calcFC(self):
	# input is FC raster array
	# compare array single values with FC look up table
	# output is new array with score values
	
		self.textEdit.append("Start calculations on input files")
	
		# create a copy of original data array
		self.arrayFC = self.dataFC[:]
		
		# iterate through the array
		for i in range(0, len(self.dataFC)):
			for j in range(0, len(self.dataFC[i])):
				for k in range(0, len(self.FCMax)):														# iterate through each cell of look up table
					if (self.dataFC[i][j] > self.FCMin[k]) and (self.dataFC[i][j] <= self.FCMax[k]):	# check if array value lies inside the given intervals of look up table
						self.arrayFC[i][j] = self.FCPoints[k]											# array value gets score value from look up table
						break																			# end this conditions and go on with next cell
				if (self.dataFC[i][j] == self.FCMax[-1]):												# if array value equals the upper limit give the proper score
					self.arrayFC[i][j] = self.FCPoints[-1]
				
				elif (self.dataFC[i][j]) < 0:
					self.arrayFC[i][j] = 0
				
		
		print "FC at 1: ", self.dataFC[1][1]
		print "FC Score at 240, 103: ", self.arrayFC[240][103]
		
		self.textEdit.append("Calculated on FC raster")

	# --------------------------------------
	# calculate GWR array
	# --------------------------------------	
	
	def calcGWR(self):
	# input is GWR raster array
	# compare array single values with GWR look up table
	# output is new array with score values
	
		# create a copy of original data array
		self.arrayGWR = self.dataPercol[:]
		
		# iterate through the array
		for i in range(0, len(self.dataPercol)):
			for j in range(0, len(self.dataPercol[i])):
				for k in range(0, len(self.GWRMax)):															# iterate through each cell of look up table
					if (self.dataPercol[i][j] > self.GWRMin[k]) and (self.dataPercol[i][j] <= self.GWRMax[k]):	# check if array value lies inside the given intervals of look up table
						self.arrayGWR[i][j] = self.GWRPoints[k]													# array value gets score value from look up table
						break																					# end this conditions and go on with next cell
				if (self.dataPercol[i][j] == self.GWRMax[-1]):													# if array value equals the upper limit give the proper score
					self.arrayGWR[i][j] = self.GWRPoints[-1]

				elif (self.dataPercol[i][j]) < 0:
					self.arrayGWR[i][j] = 0
					
		print "GWR at 1: ", self.dataPercol[1][1]	
		print "GWR Score at 240, 103: ", self.arrayGWR[240][103]
		
		self.textEdit.append("Calculated on GWR raster")

	# --------------------------------------
	# calculate CWB array
	# --------------------------------------
		
	def calcCWB(self):
	# input is CWB raster array
	# compare array single values with CWB look up table
	# output is new array with score values

	
	
		# create a copy of original data array
		self.arrayCWB = self.dataPercol[:]

		
		
		# iterate through the array
		for i in range(0, len(self.dataPercol)):
			for j in range(0, len(self.dataPercol[i])):
				for k in range(0, len(self.CWBMax)):															# iterate through each cell of look up table
					if (self.dataPercol[i][j] > self.CWBMin[k]) and (self.dataPercol[i][j] <= self.CWBMax[k]):	# check if array value lies inside the given intervals of look up table
						self.arrayCWB[i][j] = self.CWBPoints[k]													# array value gets score value from look up table
						break																	# end this conditions and go on with next cell
				if (self.dataPercol[i][j] == self.CWBMax[-1]):													# if array value equals the upper limit give the proper score
					self.arrayCWB[i][j] = self.CWBPoints[-1]

				elif (self.dataPercol[i][j]) < 0:
					self.arrayCWB[i][j] = 0					
					
		print "CWB at 1: ", self.dataPercol[1][1]	
		print "CWB Score at 240, 103: ", self.arrayCWB[240][103]	
		
		self.textEdit.append("Calculated on CWB raster")
		
	# --------------------------------------
	# calculate LITH array
	# --------------------------------------	
	
	def calcLITH_l(self):
		gdal.AllRegister()
		
		self.arrayLITH_l = 0
		LITHValue_l = 0

		for index, layer in enumerate(self.lith_l.LITH_l_files):
			lith = self.lith_l.short_list_l[index].split(": ")[0]
			org = self.lith_l.short_list_l[index].split(": ")[1]
			
			for i in range(0, len(self.LITHShort_l)):
				if lith == self.LITHShort_l[i] and org == "No":
					LITHValue_l = self.LITHPoints_l[i]
					
				elif lith == self.LITHShort_l[i] and org == "Yes":
					LITHValue_l = self.LITHPoints_l[i] + 75
			
			imgLITH_l = gdal.Open(layer)
			dataLITH_l = imgLITH_l.ReadAsArray()
			LITH_copy = dataLITH_l[:]
			LITH_copy = dataLITH_l[:] * LITHValue_l
	
			self.arrayLITH_l += LITH_copy
			self.arrayLITH_l = self.arrayLITH_l.astype(float)	
			
			print "LITHL Score at 240, 103: ", self.arrayLITH_l[240][103]
			
		self.textEdit.append("Calculated on unconsolidated lithology")	

			

	def calcLITH_s(self):
		gdal.AllRegister()
		
		self.arrayLITH_s = 0
		LITHValue_type = 0
		LITHValue_struc = 0

		for index, layer in enumerate(self.lith_s.LITH_s_files):
			type = self.lith_s.asso_list_s[index].split(", ")[0]
			struc = self.lith_s.asso_list_s[index].split(", ")[1]
			for i in range(0, len(self.LITHName_type)):
				if type == self.LITHName_type[i]:
					LITHValue_type = self.LITHPoints_type[i]
					
			for j in range(0, len(self.LITHName_struc)):
				if struc == self.LITHName_struc[j]:
					LITHValue_struc = self.LITHPoints_struc[j]		
			
			imgLITHs = gdal.Open(layer)
			dataLITH_s = imgLITHs.ReadAsArray()
			LITH_copy = dataLITH_s[:]
			LITH_copy = dataLITH_s[:] * (LITHValue_type * LITHValue_struc)
	
			self.arrayLITH_s += LITH_copy
			self.arrayLITH_s = self.arrayLITH_s.astype(float)
			
			print "LITHS Score at 240, 103: ", self.arrayLITH_s[240][103]
			
		self.textEdit.append("Calculated on consolidated lithology")
		
	# --------------------------------------
	# calculate S1 array
	# --------------------------------------
	
	def calcS1(self):
	
		self.textEdit.append("Calculated on input files")
	
		if self.rbtnGWR.isChecked():
			self.arrayS1 = self.arrayFC * self.arrayGWR
		elif self.rbtnCWB.isChecked():
			self.arrayS1 = self.arrayFC * self.arrayCWB

	# --------------------------------------
	# calculate S2 array
	# --------------------------------------
	
	def calcS2(self):
	
		if self.rbtnGWR.isChecked():
			self.arrayS2 = ((self.arrayLITH_l + self.arrayLITH_s) * self.arrayGWR) + self.arrayPerched + self.arrayArtesian
		elif self.rbtnCWB.isChecked():
			self.arrayS2 = ((self.arrayLITH_l + self.arrayLITH_s) * self.arrayCWB) + self.arrayPerched + self.arrayArtesian
	
	# --------------------------------------
	# start calculations on GWP file
	# --------------------------------------

	def calcGLA(self):
		self.calcS1()
		self.calcS2()

		self.arrayGWP = self.arrayS1 + self.arrayS2	
		
		print "GWP Score at 240, 103: ", self.arrayGWP[240][103]
	
	# --------------------------------------
	# write output file
	# --------------------------------------
	
	def writeTextureGeoTiff(self):
		# input are resulting arrays and georeference information
		# write given array data to the output files

		
		path, filename = os.path.split(self.outName)
		name = os.path.splitext(filename)[0]
		extension = os.path.splitext(filename)[1]
		
		if extension == ".tif":
			format = "GTiff"
		elif extension == ".grd":
			format = "GSAG"
		
		driver = gdal.GetDriverByName( format )
		NOVALUE = -999
		metadata = driver.GetMetadata()
		datatype = gdal.GDT_Float32
		if metadata.has_key(gdal.DCAP_CREATE) \
			and metadata[gdal.DCAP_CREATE] == 'YES':
			pass
		else:
			QMessageBox.information(None,"info","Driver %s does not support Create() method." % format)
			return False
	
		# get image size and number of bands
		self.end_rows = self.spb_row.value()
		self.end_cols = self.spb_col.value()

		self.end_xmin = self.spb_xmin.value()
		self.end_xmax = self.spb_xmax.value()
		self.end_ymin = self.spb_ymin.value()
		self.end_ymax = self.spb_ymax.value()
		
		self.end_pxWidth = (self.end_xmax - self.end_xmin) / self.end_cols
		self.end_pxHeight = (self.end_ymax - self.end_ymin) / self.end_rows

		outDataset = driver.Create(str(self.outName), self.end_cols, self.end_rows, 1, datatype)
		outDataset.GetRasterBand(1).WriteArray(self.arrayGWP)
		#outDataset.SetNoDataValue(NOVALUE)
		outDataset.SetGeoTransform([self.end_xmin, self.end_pxWidth, self.rotation2, self.end_ymax, self.rotation4, -self.end_pxHeight])
		
		self.textEdit.append("GLA layer calculated successfully and saved to directory")
		
		return True
		
		
		
#		self.spb_row.setValue(self.rows)
#		self.spb_col.setValue(self.cols)
#		self.spb_xmin.setValue(self.XMin)
#		self.spb_ymax.setValue(self.YMax)
#		self.spb_xmax.setValue(self.XMax)
#		self.spb_ymin.setValue(self.YMin)		
		
		

	# --------------------------------------
	# load output into QGIS
	# --------------------------------------
			
	def loadTextureRaster(self, outName):
		# when checked in UI, load new created raster into QGIS
		
		"Load texture map in TOC"
		fileInfo = QFileInfo(self.outName)
		baseName = fileInfo.baseName()
		rlayer = QgsRasterLayer(self.outName, baseName)
		if not rlayer.isValid():
			self.textEdit.append("Layer failed to load!")
		#rlayer.setDrawingStyle(QgsRasterLayer.SingleBandPseudoColor)
		#rlayer.setColorShadingAlgorithm(QgsRasterLayer.FreakOutShader)
		QgsMapLayerRegistry.instance().addMapLayer(rlayer)
		return rlayer
		
	# --------------------------------------
	# write processing files
	# --------------------------------------
	
	def writeProcessGeoTiff(self):
		# input are resulting arrays and georeference information
		# write given array data to the output files

		# split output filename into directory and file
		# use directory as output directory
		path, filename = os.path.split(self.outName)
		outdir = "Processing Rasters"
		outdir = os.path.join(path, outdir)
		
		try:
		#if not os.path.exists(outName):
			os.mkdir(outdir)
		except:
			pass
		
		outFC = "outFC.tif"
		outFC = os.path.join(outdir, outFC)

		if self.rbtnGWR.isChecked():
			outGWR = "outGWR.tif"
			outGWR = os.path.join(outdir, outGWR)
			
		elif self.rbtnCWB.isChecked():
			outCWB = "outCWB.tif"
			outCWB = os.path.join(outdir, outCWB)
		
		outLITH_l = "outLITH_l.tif"
		outLITH_l = os.path.join(outdir, outLITH_l)
		
		outLITH_s = "outLITH_s.tif"
		outLITH_s = os.path.join(outdir, outLITH_s)	
		
		format = "GTiff"
		driver = gdal.GetDriverByName( format )
		NOVALUE = -999
		metadata = driver.GetMetadata()
		datatype = gdal.GDT_Float32
		if metadata.has_key(gdal.DCAP_CREATE) \
			and metadata[gdal.DCAP_CREATE] == 'YES':
			pass
		else:
			QMessageBox.information(None,"info","Driver %s does not support Create() method." % format)
			return False

		outDatasetFC = driver.Create(str(outFC), self.cols, self.rows, 1, datatype)
		outDatasetFC.GetRasterBand(1).WriteArray(self.arrayFC)
		#outDataset.SetNoDataValue(NOVALUE)
		outDatasetFC.SetGeoTransform([self.end_xmin, self.end_pxWidth, self.rotation2, self.end_ymax, self.rotation4, -self.end_pxHeight])
		
		if self.rbtnGWR.isChecked():
			outDatasetGWR = driver.Create(str(outGWR), self.cols, self.rows, 1, datatype)
			outDatasetGWR.GetRasterBand(1).WriteArray(self.arrayGWR)
			#outDataset.SetNoDataValue(NOVALUE)
			outDatasetGWR.SetGeoTransform([self.end_xmin, self.end_pxWidth, self.rotation2, self.end_ymax, self.rotation4, -self.end_pxHeight])
		
		elif self.rbtnCWB.isChecked():
			outDatasetCWB = driver.Create(str(outCWB), self.cols, self.rows, 1, datatype)
			outDatasetCWB.GetRasterBand(1).WriteArray(self.arrayCWB)
			#outDataset.SetNoDataValue(NOVALUE)
			outDatasetCWB.SetGeoTransform([self.end_xmin, self.end_pxWidth, self.rotation2, self.end_ymax, self.rotation4, -self.end_pxHeight])
		
		if (len(self.lith_l.asso_list_l)):
			outDatasetLITH_l = driver.Create(str(outLITH_l), self.cols, self.rows, 1, datatype)
			outDatasetLITH_l.GetRasterBand(1).WriteArray(self.arrayLITH_l)
			#outDataset.SetNoDataValue(NOVALUE)
			outDatasetLITH_l.SetGeoTransform([self.end_xmin, self.end_pxWidth, self.rotation2, self.end_ymax, self.rotation4, -self.end_pxHeight])
		
		if (len(self.lith_s.asso_list_s)):
			outDatasetLITH_s = driver.Create(str(outLITH_s), self.cols, self.rows, 1, datatype)
			outDatasetLITH_s.GetRasterBand(1).WriteArray(self.arrayLITH_s)
			#outDataset.SetNoDataValue(NOVALUE)
			outDatasetLITH_s.SetGeoTransform([self.end_xmin, self.end_pxWidth, self.rotation2, self.end_ymax, self.rotation4, -self.end_pxHeight])
		
		self.textEdit.append("Process rasters saved to directory")	
		